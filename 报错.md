# 简易的grpc通信项目问题

## 一、std::move
这个代码，std::shared_ptr<Channel> channel = grpc::CreateChannel(host + ":" + port, 
                                                                   grpc::InsecureChannelCredentials());
这一段如果我直接传入host会报错，传入host_就正常运行，是std::move的原因导致传入host报错

``` cpp
class Conpool 
{
public:
    Conpool(size_t poolSize,std::string host, std::string port)
            : b_stop_(false),
              poolSize_(poolSize),
              host_(std::move(host)),
              port_(std::move(port))
    {
        for(size_t i = 0; i < poolSize;i++)
        {
            std::shared_ptr<Channel> channel = grpc::CreateChannel(host + ":" + port, 
                                                                   grpc::InsecureChannelCredentials());
            connections_.push(Grpc_test::NewStub(channel));
        }
    }

    


private:
    std::atomic<bool> b_stop_;
    size_t poolSize_;
    std::string host_;
    std::string port_;
    std::queue<std::unique_ptr<Grpc_test::Stub>> connections_;
    std::mutex mutex_;
    std::condition_variable cond_;
};
```

**这个问题本质上就是 `std::move` 导致的，而且是一个非常典型、也很隐蔽的 C++ bug。**
你现在这段代码里，**在构造函数体内继续使用了已经被 `std::move` 过的参数 `host` / `port`**。

---

## 关键问题在哪一行

构造函数初始化列表：

```cpp
host_(std::move(host)),
port_(std::move(port))
```

这两行做了什么？

* 把 **构造函数参数 `host` / `port` 的内容移动到成员变量**
* 移动之后：

  * `host`、`port` **仍然是有效对象**
  * 但它们处于 **valid but unspecified state（有效但未指定状态）**

对 `std::string` 来说，**常见实现中会变成空字符串**。

---

## 接下来你在构造函数体里做了什么

```cpp
grpc::CreateChannel(host + ":" + port, ...)
```

⚠️ 这里用的是 **参数 `host` / `port`，不是成员 `host_` / `port_`**。

此时极有可能发生的是：

```cpp
host == ""
port == ""
```

于是你传给 gRPC 的地址是：

```text
":"          // 非法地址
```

这就是为什么：

* ❌ 直接用 `host` → 报错 / 连接失败
* ✅ 用 `host_` → 正常运行

---

## 这是不是 UB（未定义行为）？

**不是 UB**，但这是**逻辑错误**：

* 移动后的 `std::string`：

  * ✔ 可以析构
  * ✔ 可以重新赋值
  * ❌ 不应该再依赖其内容

---

## 为什么换成 `host_` 就好了

```cpp
grpc::CreateChannel(host_ + ":" + port_, ...)
```

因为：

* `host_` / `port_` 才是真正持有字符串内容的对象
* 它们刚刚通过 `std::move` 得到了有效值

---

## 正确写法（推荐）

### ✅ 写法一（最直接、最安全）

```cpp
Conpool(size_t poolSize, std::string host, std::string port)
    : b_stop_(false),
      poolSize_(poolSize),
      host_(std::move(host)),
      port_(std::move(port))
{
    for (size_t i = 0; i < poolSize_; i++) {
        auto channel = grpc::CreateChannel(
            host_ + ":" + port_,
            grpc::InsecureChannelCredentials()
        );
        connections_.push(Grpc_test::NewStub(channel));
    }
}
```

---

### ✅ 写法二（避免构造函数参数被 move 后误用）

```cpp
Conpool(size_t poolSize,
        const std::string& host,
        const std::string& port)
    : b_stop_(false),
      poolSize_(poolSize),
      host_(host),
      port_(port)
{
    ...
}
```

适合你 **不关心拷贝成本** 或 host/port 很短的情况。

---

### 🚫 你现在的写法违反了一条重要 C++ 经验法则

> **被 `std::move` 过的对象，不应再参与业务逻辑**

哪怕它“还能用”。

---

## 一句话总结（面试级）

> 构造函数参数 `host` 在初始化列表中被 `std::move` 后处于有效但未指定状态，
> 构造函数体中继续使用它拼接地址，导致 gRPC 接收到非法的 `" : "` 地址；
> 使用成员变量 `host_` / `port_` 才是正确做法。

如果你愿意，我可以顺便帮你检查这段代码在
**线程安全、连接池设计、shared_ptr / unique_ptr 混用** 上还有没有潜在坑。

### 总结: 
**构造函数参数 `host` 在初始化列表中被 `std::move` 后处于有效但未指定状态，被 `std::move` 过的对象，不应再参与业务逻辑; 被 std::move 过的对象仍然是有效的，但其值处于“未指定状态”，不应再依赖其内容参与业务逻辑。(对象还活着，只是内部资源被转移走了,例如string s被move后可以继续push、clear等,但不能再调用,除非重新赋值)**